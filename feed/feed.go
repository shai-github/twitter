package feed

import (
	"math"
	"proj1/lock"
)

// Feed represents a user's twitter feed
type Feed interface {
	Add(body string, timestamp float64)
	Remove(timestamp float64) bool
	Contains(timestamp float64) bool
	Output() *OutFeed
}

// feed is the internal representation of a user's twitter feed (hidden from outside packages)
type feed struct {
	head *post
	tail *post
	lock *lock.RWLock
}

// post is the internal representation of a post on a user's twitter feed (hidden from outside packages)
type post struct {
	body      string
	timestamp float64
	next      *post
}

// struct for post to be generated by Feed request
type OutPost struct {
	Body      string
	Timestamp float64
}

// struct for feed that stores posts generated by Feed request
type OutFeed struct {
	Id   int32
	Feed []OutPost
}

// NewPost creates and returns a new post value given its body and timestamp
func newPost(body string, timestamp float64, next *post) *post {
	return &post{body, timestamp, next}
}

// NewFeed creates a empty user feed
func NewFeed() Feed {
	tail := post{timestamp: -math.MaxFloat64, next: nil}
	head := post{timestamp: math.MaxFloat64, next: &tail}
	link := feed{head: &head, tail: &tail, lock: lock.NewRWLock(int32(32))}
	return &link
}

// Add inserts a new post to the feed. The feed is always ordered by the timestamp where
// the most recent timestamp is at the beginning of the feed followed by the second most
// recent timestamp, etc.
func (f *feed) Add(body string, timestamp float64) {
	f.lock.Lock()
	defer f.lock.Unlock()
	for {
		pred := f.head
		curr := f.head.next
		for curr.timestamp > timestamp {
			pred = curr
			curr = curr.next
		}

		thisPost := newPost(body, timestamp, curr)
		pred.next = thisPost
		return
	}
}

// Remove deletes the post with the given timestamp. If the timestamp
// is not included in a post of the feed then the feed remains
// unchanged. Return true if the deletion was a success, otherwise return false
func (f *feed) Remove(timestamp float64) bool {
	f.lock.Lock()
	defer f.lock.Unlock()
	for {
		pred := f.head
		curr := f.head.next
		for curr.timestamp > timestamp {
			pred = curr
			curr = curr.next
		}
		if curr.timestamp == timestamp {
			pred.next = curr.next
			return true
		} else {
			return false
		}
	}
}

// Contains determines whether a post with the given timestamp is
// inside a feed. The function returns true if there is a post
// with the timestamp, otherwise, false.
func (f *feed) Contains(timestamp float64) bool {
	f.lock.RLock()
	defer f.lock.RUnlock()
	curr := f.head
	for curr.timestamp > timestamp {
		curr = curr.next
	}
	return curr.timestamp == timestamp
}

// Output returns a pointer to a feed to display posts generated by Feed request
func (f *feed) Output() *OutFeed {

	f.lock.RLock()
	defer f.lock.RUnlock()
	pred := f.head
	curr := pred.next

	results := make([]OutPost, 0)
	for {
		newPost := OutPost{Body: curr.body, Timestamp: curr.timestamp}
		if len(newPost.Body) > 0 {
			results = append(results, newPost)
		}
		if curr.next == nil {
			break
		} else {
			curr = curr.next
		}
	}

	feedResults := OutFeed{Feed: results}
	return &feedResults
}
