package feed

import (
	"math"
	"sync"
)

// Feed represents a user's twitter feed
type Feed interface {
	Add(body string, timestamp float64)
	Remove(timestamp float64) bool
	Contains(timestamp float64) bool
	Output() *OutFeed
}

// feed is the internal representation of a user's twitter feed (hidden from outside packages)
type feed struct {
	head *post
	tail *post
}

// post is the internal representation of a post on a user's twitter feed (hidden from outside packages)
type post struct {
	body      string
	timestamp float64
	next      *post
	marked    bool
	lock      sync.Mutex
}

// struct for post to be generated by Feed request
type OutPost struct {
	Body      string
	Timestamp float64
}

// struct for feed that stores posts generated by Feed request
type OutFeed struct {
	Id   int32
	Feed []OutPost
}

// checks that neither the pred nor the curr nodes has been logically deleted, and that pred points to curr
func validate(pred *post, curr *post) bool {
	return !pred.marked && !curr.marked && pred.next == curr
}

// NewPost creates and returns a new post value given its body and timestamp
func newPost(body string, timestamp float64, next *post, marked bool) *post {
	return &post{body: body, timestamp: timestamp, next: next, marked: marked}
}

// NewFeed creates a empty user feed
func NewFeed() Feed {

	tail := post{timestamp: -math.MaxFloat64, next: nil, marked: false}
	head := post{timestamp: math.MaxFloat64, next: &tail, marked: false}
	link := feed{head: &head, tail: &tail}
	return &link
}

// Add inserts a new post to the feed. The feed is always ordered by the
// timestamp where the most recent timestamp is at the beginning of the feed
// followed by the second most recent timestamp, etc.
func (f *feed) Add(body string, timestamp float64) {
	for {
		pred := f.head
		curr := f.head.next
		for curr.timestamp > timestamp {
			pred = curr
			curr = curr.next
		}

		pred.lock.Lock()
		curr.lock.Lock()

		if validate(pred, curr) {
			if curr.timestamp == timestamp {
				curr.lock.Unlock()
				pred.lock.Unlock()
				break
			} else {
				thisPost := newPost(body, timestamp, curr, false)
				pred.next = thisPost
				curr.lock.Unlock()
				pred.lock.Unlock()
				break
			}
		}
		curr.lock.Unlock()
		pred.lock.Unlock()
	}
}

// Remove deletes the post with the given timestamp. If the timestamp
// is not included in a post of the feed then the feed remains
// unchanged. Return true if the deletion was a success, otherwise return false
func (f *feed) Remove(timestamp float64) bool {
	for {
		pred := f.head
		curr := f.head.next
		for curr.timestamp > timestamp {
			pred = curr
			curr = curr.next
		}

		pred.lock.Lock()
		curr.lock.Lock()

		if validate(pred, curr) {
			if curr.timestamp != timestamp {
				curr.lock.Unlock()
				pred.lock.Unlock()
				return false
			} else {
				curr.marked = true
				pred.next = curr.next
				curr.lock.Unlock()
				pred.lock.Unlock()
				return true
			}
		}
		curr.lock.Unlock()
		pred.lock.Unlock()
	}
}

// Contains determines whether a post with the given timestamp is
// inside a feed. The function returns true if there is a post
// with the timestamp, otherwise, false.
func (f *feed) Contains(timestamp float64) bool {
	curr := f.head
	for curr.timestamp > timestamp {
		curr = curr.next
	}
	return curr.timestamp == timestamp && !curr.marked
}

// Output eturns a pointer to a feed to display posts generated by Feed request
func (f *feed) Output() *OutFeed {

	pred := f.head
	curr := pred.next

	results := make([]OutPost, 0)
	for {
		newPost := OutPost{Body: curr.body, Timestamp: curr.timestamp}
		if len(newPost.Body) > 0 {
			results = append(results, newPost)
		}
		if curr.next == nil {
			break
		} else {
			curr = curr.next
		}
	}
	feedResults := OutFeed{Feed: results}
	return &feedResults
}
